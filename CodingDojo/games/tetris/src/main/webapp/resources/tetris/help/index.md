<meta charset="UTF-8">

## Вступление

Игровой demo-сервер доступен так же в интернете 24/7 в целях
ознакомления [http://codenjoy.com/codenjoy-contest](http://codenjoy.com/codenjoy-contest).

Игра с открытым исходным кодом. Для реализации своей игры, исправления
ошибок в текущей и внесения других правок необходимо для начала
[форкнуть проект](https://github.com/codenjoyme/codenjoy.git).
В корне репозитория есть описание в файле Readme.md - там описано, что делать дальше.

По возникающим вопросам, пиши в [skype alexander.baglay](skype:alexander.baglay)
или на почту [apofig@gmail.com](mailto:apofig@gmail.com).

## В чем суть игры?

Надо написать своего бота, который обыграет других ботов
по очкам в тетрис.

Каждый участник играет на своем поле. Играющий может
двигать фигуркой влево и вправо, вращать ее и приземлять.
Все так же, как в классическом тетрисе с одной лишь разницей - фигурки
появляются не сразу: как только ты научишься укладывать "квадратики",
появятся "палочки" и так далее, пока тебе не откроются все фигурки.

Чем дальше ты заходишь, тем больше очков зарабатываешь[*](#ask).

Чтобы перейти на следующий уровень, тебе необходимо укладывать
фигурки компактно, чтобы образовывались сплошные линии (от стенки к стенке),
которые затем "снимаются" (удаляются) с начислением бонусных очков[*](#ask).

Очки суммируются. Побеждает игрок с большим числом очков (до условленного
времени).

[*](#ask)Точное количество очков за любое действие, а так же другие
настройки на данный момент игры уточни у Сенсея.

## Подключение к серверу

Итак, игрок [регистрируется на сервере](../../../register?gameName=tetris),
указывая свой email.

Далее необходимо подключиться из кода к серверу через websocket.
[Эта подборка](https://github.com/codenjoyme/codenjoy-clients.git)
клиентов для разных языков программирования тебе поможет в твоей игре.
Как запустить клиент смотри в корне проекта в файле README.md.

Если ты не можешь найти свой язык - придется написать свой клиент
(а после пошарить с нами на почту [apofig@gmail.com](mailto:apofig@gmail.com))

Адрес для подключения к игре на сервере выглядит так (ты можешь скопировать его
из игровой комнаты):

`https://[server]/codenjoy-contest/board/player/[user]?code=[code]`

Тут `[server]` - домен или ip-адрес игрового сервера, `[user]` - id игрока, a `[code]` -
твой security token. Убедись что код хранится в тайне, иначе любой участник
сможет играть от твоего имени.

В коде твоего клиента тебе нужно найти похожую строчку и заменить её твоим URL -
тем самым, ты задаёшь логин/пароль для доступа к серверу.
Затем запусти твой клиент и убедись, что сервер получает команды твоего клиента.
После этого можно приступать к работе над логикой бота.

## Формат сообщений

После подключения клиент будет регулярно (каждую секунду) получать строку
символов в формате JSON — с закодированным состоянием стакана. Формат таков:

<pre>{
  'currentFigurePoint':{'x':4,'y':9},
  'currentFigureType':'O',
  'futureFigures':['S', 'Z', 'I', 'O'],
  'layers':[
    '..................
    ........OO........
    ........OO........
    ..................
    ..................
    ..................
    ..................
    ..................
    ..................
    ..................
    ..................
    ..................
    ..................
    ..................
    ..I...............
    ..I......OO.......
    ..IOO..SSOOZZ.....
    ..IOO.SSIIIIZZ....'
  ]
}</pre>

Параметр `currentFigurePoint` содержит координату новой фигурки.
`[0, 0]` - левый нижний угол.

У каждой фигурки есть своя точка вращения

![Rotate](./img/rotate.png)

Параметр `currentFigureType` содержит тип новой фигурки.

Параметр `futureFigures` говорит о последующих фигурках,
которые появятся после текущей.

Параметр `layers` содержит массив из одной строчки, которая содержит 
закодированное содержимое стакана. Длинна строки `layers[0]` 
равна площади стакана `N*N`. Если вставить символ
переноса строки каждые `N=sqrt(length(string))` символов, то
получится читабельное изображение стакана.

<pre>..................
........OO........
........OO........
..................
..................
..................
..................
..................
..................
..................
..................
..................
..................
..................
..I...............
..I......OO.......
..IOO..SSOOZZ.....
..IOO.SSIIIIZZ....</pre>

![](./img/glass.png)

Первый символ строки соответствует ячейке расположенной в 
левом верхнем углу и имеет координату `[0, 17]`.
Координата `[0, 0]` соответствует левому нижнему углу.

## Расшифровка символов

Расшифровку символов ты можешь [найти тут](elements.md).

## Как играть?

Игра пошаговая, каждую секунду сервер посылает твоему клиенту
состояние обновленного стакана на текущий момент и ожидает ответа.
За следующую секунду алгоритм игрока должен успеть принять решение,
куда направить фигурку. Если алгоритм не успел — фигурка падает на 1 клетку вниз.

Твоя цель отгадывать цифры в соответствии с задуманным тобой алгоритмом.
Играк на поле должен уметь зарабатывать так много очков, как только сможет.
Основная цель игры - обыграть по очкам всех соперников.

## Команды управления

Команд несколько:

* `LEFT, RIGHT` – передвижение фигурки влево/вправо.
* `DOWN` - приземление фигурки.
* `ACT` - вращение фигурки по часовой стрелке на 90 градусов.
* `ACT(2)` - вращение на 180 градусов.
* `ACT(3)` - вращение против часовой стрелки на 90 градусов.
* `ACT(0,0)` - обнуление стакана (как и при его переполнении будут сняты штрафные очки).
* Команды движения/вращения/приземления можно комбинировать, разделяя их
  через запятую – это значит что за один тик игры будет выполнена заданная цепочка команд.

## Настройки

Всего предусмотрено несколько бонусных и одни штрафные очки.

За одну приземленную фигуру ты получаешь количество очков, равное ее сложности.
Сложность фигурок возрастает:

* `O`  - 1 очко[*](#ask)
* `I` - 2 очка[*](#ask)
* `J` - 3 очка[*](#ask)
* `L` - 4 очка[*](#ask)
* `S` - 5 очков[*](#ask)
* `Z` - 6 очков[*](#ask)
* `T` - 7 очков[*](#ask)

Фигуры могут появляться в этой последовательности 
с каждым новым уровнем все чаще, а могут и в другом порядке - 
как именно решает Сенсей[*](#ask).

За "снятые" линии ты будешь получать больше бонусных очков[*](#ask).
Чем больше одновременно снятых линий - тем выгоднее. Например:

* за 1 "снятую" линию ты получишь `10*level` очков[*](#ask)
* за 2 "снятые" линии ты получишь уже `30*level` очков[*](#ask)
* за 3 "снятые" линии - `50*level` очков[*](#ask)
* за 4 "снятые" линии - `100*level` очков[*](#ask) 

Тут level - уровень до которого ты дошел.

Так же не стоит забывать про штрафные очки. За каждый переполненный стакан
(или если ты обнулишь его сам) ты потеряешь `10*level` заработанных 
очков[*](#ask).

Победит тот участник, кто соберет больше всего очков за ограниченное 
количество времени.

За деталями обращайся к Сенсею, вполне возможно, что эти константы,
а так же правила определения финалиста будут изменены[*](#ask).

## Кейзы

## <a id="ask"></a> Спроси Сенсея

Параметры могут изменяться по ходу игры. Настройки текущей игры
ты сможешь всегда [подглядеть тут](/codenjoy-contest/rest/settings/player).
Пожалуйста, спроси у Сенсея как интерпретировать эти данные. Ты можешь найти Сенсея
в чате, который подготовили организаторы для обсуждения вопросов.

## Подсказки

Первостепенная задача – написать websocket клиента, который подключится
к серверу. Затем заставить героя на поле слушаться команд.
Таким образом, игрок подготовится к основной игре.
Основная цель – вести осмысленную игру и победить.

## Клиент и API

Организаторы предоставляют игрокам подготовленные клиенты в исходном
коде на нескольких языках. Каждый из этих клиентов уже умеет связываться
с сервером, принимать и разбирать сообщение от сервера (обычно это называется board)
и отправлять серверу команды.

Слишком много форы клиентский код не дает играющим, поскольку в этом коде
еще надо разобраться, но там реализована логика общения с сервером +
некоторое высокоуровневое API для работы с доской (что уже приятно).

Все языки так или иначе имеют похожий набор методов:

* `Solver`
  Пустой класс с одним методом — ты должен(должна) наполнить его умной логикой.
* `Direcion`
  Возможные направления движения для этой игры.
* `Point`
  `x`, `y` координаты.
* `Element`
  Тип элемента на доске.
* `Board`
  Содержит логику для удобного поиска и манипуляции элементами на поле.
  Ты можешь найти следующие методы в Board классе:
* `int boardSize();`
  Размер доски.
* `boolean isAt(Point point, Element element);`
  Находится ли в позиции point заданный элемент?
* `boolean isAt(Point point, Collection<Element>elements);`
  Находится ли в позиции point что-нибудь из заданного набора?
* `boolean isNear(Point point, Element element);`
  Есть ли вокруг клеточки с координатой point заданный элемент?
* `int countNear(Point point, Element element);`
  Сколько элементов заданного типа есть вокруг клетки с point?
* `Element getAt(Point point);`
  Элемент в текущей клетке.
* и так далее...

## Как провести такой же ивент самостоятельно?

Перед тобой opensource проект. Для реализации своей новой игры, модификации этой игры,
любой другой модификации сервера или исправления найденной ошибки
[форкни проект](https://github.com/codenjoyme/codenjoy.git).
Все инструкции ты найдешь в Readme.md файлах - они подскажут, что делать дальше.

Если у тебя есть вопросы - прошу, задавай их мне
в [скайпе alexander.baglay](skype:alexander.baglay)
или по почте [apofig@gmail.com](mailto:apofig@gmail.com).

Удачной игры и пусть победит сильнейший! 